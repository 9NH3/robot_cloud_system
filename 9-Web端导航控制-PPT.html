<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web端导航控制 | 机器人物联网云控系统 - PPT</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f0f0f0;
            overflow-x: hidden;
        }
        
        .ppt-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .nav-container {
            background-color: #2c3e50;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .nav-container h1 {
            font-size: 1.5rem;
            margin: 0;
        }
        
        .nav-buttons {
            display: flex;
            gap: 10px;
        }
        
        .nav-buttons button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .nav-buttons button:hover {
            background-color: #2980b9;
        }
        
        .slides-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            scroll-behavior: smooth;
        }
        
        .slide {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin: 0 auto 30px;
            padding: 40px;
            width: 100%;
            max-width: 1024px;
            min-height: 80vh;
            position: relative;
        }
        
        .slide-title {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
            margin-bottom: 25px;
            text-align: center;
        }
        
        .slide-content {
            font-size: 1.2rem;
            line-height: 1.6;
        }
        
        .slide-content h3 {
            color: #3498db;
            margin: 20px 0 10px;
        }
        
        .slide-content h4 {
            color: #2c3e50;
            margin: 15px 0 8px;
        }
        
        .slide-content ul, .slide-content ol {
            margin: 10px 0 10px 30px;
        }
        
        .slide-content li {
            margin-bottom: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        
        th {
            background-color: #3498db;
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        code {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .formula {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: center;
            font-style: italic;
            border-left: 4px solid #e74c3c;
        }
        
        .caption {
            font-style: italic;
            text-align: center;
            margin-top: 5px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .footer {
            text-align: center;
            padding: 10px;
            color: #7f8c8d;
            font-size: 0.9rem;
            position: absolute;
            bottom: 10px;
            width: 100%;
            left: 0;
        }
        
        .two-columns {
            display: flex;
            gap: 20px;
        }
        
        .two-columns > div {
            flex: 1;
        }
        
        @media (max-width: 768px) {
            .slide {
                padding: 20px;
                min-height: auto;
            }
            
            .two-columns {
                flex-direction: column;
            }
            
            .nav-container {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        /* 打印样式 */
        @media print {
            body {
                background-color: white;
            }
            
            .nav-container {
                display: none;
            }
            
            .slide {
                box-shadow: none;
                page-break-after: always;
                margin: 0;
                height: auto;
            }
            
            .slides-container {
                overflow: visible;
                padding: 0;
            }
        }

        .export-btn {
            background-color: #27ae60 !important;
        }
        
        .export-btn:hover {
            background-color: #219653 !important;
        }
    </style>
</head>
<body>
    <div class="ppt-container">
        <div class="nav-container">
            <h1>Web端导航控制 | 机器人物联网云控系统 - PPT文档</h1>
            <div class="nav-buttons">
                <button onclick="navigate('prev')">上一张</button>
                <button onclick="navigate('home')">回到首页</button>
                <button onclick="navigate('next')">下一张</button>
                <button class="export-btn" onclick="exportToPDF()">导出PDF</button>
            </div>
        </div>
        
        <div class="slides-container" id="slides-container">
            <!-- 幻灯片开始 -->
            
            <!-- 封面页 -->
            <div class="slide" id="slide1">
                <h1 class="slide-title">第九次课：Web端导航控制</h1>
                <div class="slide-content" style="text-align: center; margin-top: 100px;">
                    <h2>机器人物联网云控系统</h2>
                    <p style="margin-top: 50px; font-size: 1.5rem;">任务四：Web端SLAM与导航</p>
                    <p style="margin-top: 100px;">环境：Ubuntu 22.04 + ROS2 Humble</p>
                </div>
                <div class="footer">第 1 页</div>
            </div>
            
            <!-- 课程内容介绍 -->
            <div class="slide" id="slide2">
                <h2 class="slide-title">一、课程内容介绍</h2>
                <div class="slide-content">
                    <p>本节课是机器人物联网云控系统课程的第九次课，属于任务四"Web端SLAM与导航"的第二部分。重点讲解如何实现Web端的导航控制功能。</p>
                    
                    <h3>主要内容</h3>
                    <ul>
                        <li>ROS 2导航栈的基本原理与架构</li>
                        <li>动作服务器与客户端的使用方法</li>
                        <li>导航任务队列的设计与实现</li>
                        <li>导航状态监控与反馈机制</li>
                        <li>Web前端导航控制界面开发</li>
                    </ul>
                    
                    <h3>课程目标</h3>
                    <p>实现一个完整的Web端导航控制系统，为后续的多目标点路径规划和任务管理打下基础。</p>
                </div>
                <div class="footer">第 2 页</div>
            </div>
            
            <!-- 学习目标 -->
            <div class="slide" id="slide3">
                <h2 class="slide-title">二、学习目标及与后续课程关联</h2>
                <div class="slide-content">
                    <h3>学习目标</h3>
                    <ul>
                        <li>理解ROS 2导航栈的工作原理</li>
                        <li>掌握动作服务器与客户端的使用方法</li>
                        <li>能够实现导航任务队列管理系统</li>
                        <li>学会监控和反馈导航状态</li>
                        <li>掌握Web端导航控制界面的开发技术</li>
                    </ul>
                    
                    <h3>与后续课程的关联</h3>
                    <ul>
                        <li><strong>第十次课（多目标点路径规划）</strong>：基于本节课实现的导航控制功能</li>
                        <li><strong>第十一和十二次课（任务管理系统与集成）</strong>：将导航控制功能集成到完整的任务管理系统中</li>
                    </ul>
                    
                    <p>本节课实现的导航控制功能是整个机器人云控系统的核心功能之一，后续所有高级功能都将在此基础上构建。</p>
                </div>
                <div class="footer">第 3 页</div>
            </div>
            
            <!-- 核心技术点1 -->
            <div class="slide" id="slide4">
                <h2 class="slide-title">三、核心技术点：ROS 2导航栈原理与架构</h2>
                <div class="slide-content">
                    <p>ROS 2导航栈（Nav2）是一个用于实现自主导航的框架，提供了一系列功能包，用于处理地图、定位、路径规划和控制器等任务。</p>
                    
                    <h3>导航栈核心组件</h3>
                    <table>
                        <tr>
                            <th>组件</th>
                            <th>功能描述</th>
                            <th>关键话题/服务</th>
                        </tr>
                        <tr>
                            <td>AMCL</td>
                            <td>自适应蒙特卡洛定位，用于机器人定位</td>
                            <td>/amcl_pose, /particle_cloud</td>
                        </tr>
                        <tr>
                            <td>BT Navigator</td>
                            <td>行为树导航器，协调导航任务</td>
                            <td>/navigate_to_pose (动作)</td>
                        </tr>
                        <tr>
                            <td>Planner Server</td>
                            <td>路径规划服务器，生成全局路径</td>
                            <td>/plan (服务)</td>
                        </tr>
                        <tr>
                            <td>Controller Server</td>
                            <td>控制器服务器，执行局部路径跟踪</td>
                            <td>/cmd_vel (话题)</td>
                        </tr>
                        <tr>
                            <td>Behavior Server</td>
                            <td>行为服务器，处理特殊情况</td>
                            <td>/behavior (服务)</td>
                        </tr>
                    </table>
                    
                    <p class="caption">表1：ROS 2导航栈核心组件</p>
                </div>
                <div class="footer">第 4 页</div>
            </div>
            
            <!-- 核心技术点2 -->
            <div class="slide" id="slide5">
                <h2 class="slide-title">核心技术点：导航栈工作流程</h2>
                <div class="slide-content">
                    <p>从Web前端发送导航目标到机器人实际执行导航的完整工作流程：</p>
                    
                    <table>
                        <tr>
                            <th>步骤</th>
                            <th>组件/角色</th>
                            <th>动作</th>
                            <th>数据流</th>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>Web前端</td>
                            <td>用户设置导航目标</td>
                            <td>目标坐标 → Web服务器</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>Web服务器</td>
                            <td>通过动作客户端发送导航目标</td>
                            <td>NavigateToPose目标 → Nav2</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Nav2 BT Navigator</td>
                            <td>接收导航目标，启动导航任务</td>
                            <td>调用规划器和控制器</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Planner Server</td>
                            <td>计算全局路径</td>
                            <td>路径信息 → Controller Server</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>Controller Server</td>
                            <td>生成控制命令，驱动机器人</td>
                            <td>速度命令 → /cmd_vel话题</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>AMCL</td>
                            <td>实时定位机器人位置</td>
                            <td>位姿信息 → 各组件</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Web服务器</td>
                            <td>监控导航状态，反馈给前端</td>
                            <td>状态信息 → Web前端</td>
                        </tr>
                    </table>
                    
                    <p class="caption">表2：导航栈工作流程</p>
                </div>
                <div class="footer">第 5 页</div>
            </div>
            
            <!-- 核心技术点3 -->
            <div class="slide" id="slide6">
                <h2 class="slide-title">核心技术点：动作服务器与客户端</h2>
                <div class="slide-content">
                    <p>ROS 2中的动作（Action）是一种基于话题和服务的通信机制，适用于长时间运行的任务，如导航。</p>
                    
                    <h3>动作通信模型</h3>
                    <pre><code># NavigateToPose动作定义
# Goal - 导航目标，包含目标位姿和行为树配置
geometry_msgs/PoseStamped pose  # 目标位姿，包含位置和朝向
string behavior_tree            # 使用的行为树文件(可选)

# Result - 导航结果，通常为空，因为状态信息通过反馈提供
std_msgs/Empty result

# Feedback - 导航反馈，包含当前状态信息
geometry_msgs/PoseStamped current_pose      # 当前机器人位姿
nav_msgs/Path navigation_time               # 已导航时间
int32 number_of_recoveries                  # 恢复行为执行次数</code></pre>
                    
                    <h3>动作客户端工作流程</h3>
                    <table>
                        <tr>
                            <th>步骤</th>
                            <th>方法</th>
                            <th>描述</th>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>wait_for_server()</td>
                            <td>等待动作服务器可用</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>send_goal_async()</td>
                            <td>异步发送目标</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>add_done_callback()</td>
                            <td>添加完成回调函数</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>get_result_async()</td>
                            <td>异步获取结果</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>add_feedback_callback()</td>
                            <td>添加反馈回调函数（可选）</td>
                        </tr>
                    </table>
                </div>
                <div class="footer">第 6 页</div>
            </div>
            
            <!-- 核心技术点4 -->
            <div class="slide" id="slide7">
                <h2 class="slide-title">核心技术点：动作客户端代码示例</h2>
                <div class="slide-content">
                    <p>实现ROS 2导航动作客户端的完整代码示例：</p>
                    
                    <pre><code># 创建动作客户端
# 导入必要的ROS 2模块
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus

class NavigationActionClient(Node):
    def __init__(self):
        super().__init__('navigation_action_client')
        
        # 创建动作客户端，连接到NavigateToPose动作服务器
        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.get_logger().info('导航动作客户端已初始化')

    # 发送导航目标
    def send_navigation_goal(self, x, y):
        # 等待服务器可用，设置5秒超时
        if not self.nav_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('导航服务器未响应')
            return False
        
        # 创建目标消息
        goal_msg = NavigateToPose.Goal()
        pose = PoseStamped()
        pose.header.frame_id = 'map'  # 使用map坐标系
        pose.header.stamp = self.get_clock().now().to_msg()
        pose.pose.position.x = x  # 目标点x坐标
        pose.pose.position.y = y  # 目标点y坐标
        pose.pose.orientation.w = 1.0  # 默认朝向，四元数表示无旋转
        
        goal_msg.pose = pose
        
        # 发送目标并设置反馈回调
        self.send_goal_future = self.nav_client.send_goal_async(
            goal_msg, 
            feedback_callback=self.feedback_callback
        )
        # 添加目标响应回调
        self.send_goal_future.add_done_callback(self.goal_response_callback)
        
        return True

    # 目标响应回调
    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('导航目标被拒绝')
            return
        
        self.get_logger().info('导航目标已接受')
        self.get_result_future = goal_handle.get_result_async()
        self.get_result_future.add_done_callback(self.get_result_callback)

    # 结果回调
    def get_result_callback(self, future):
        result = future.result().result
        status = future.result().status
        if status == GoalStatus.STATUS_SUCCEEDED:
            self.get_logger().info('导航成功完成')
        else:
            self.get_logger().info(f'导航失败，状态码: {status}')
        
        # 发送导航结果到Web客户端（假设已集成SocketIO）
        # socketio.emit('navigation_result', {
        #     'status': 'completed' if status == GoalStatus.STATUS_SUCCEEDED else 'failed',
        #     'message': '导航完成' if status == GoalStatus.STATUS_SUCCEEDED else '导航失败'
        # })

    # 反馈回调
    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        # 发送导航反馈到Web客户端
        # socketio.emit('navigation_feedback', {
        #     'current_pose': {
        #         'x': feedback.current_pose.pose.position.x,
        #         'y': feedback.current_pose.pose.position.y
        #     },
        #     'navigation_time': feedback.navigation_time.sec,
        #     'number_of_recoveries': feedback.number_of_recoveries
        # })
        self.get_logger().info(f'当前位置: ({feedback.current_pose.pose.position.x:.2f}, '
                              f'{feedback.current_pose.pose.position.y:.2f})')</code></pre>
                </div>
                <div class="footer">第 7 页</div>
            </div>
            
            <!-- 核心技术点5 -->
            <div class="slide" id="slide8">
                <h2 class="slide-title">核心技术点：导航任务队列管理</h2>
                <div class="slide-content">
                    <p>在实际应用中，通常需要管理多个导航任务，按顺序或按优先级执行。任务队列管理系统负责接收、排序、执行和监控多个导航任务。</p>
                    
                    <h3>任务状态管理</h3>
                    <table>
                        <tr>
                            <th>状态</th>
                            <th>描述</th>
                            <th>可能的下一个状态</th>
                        </tr>
                        <tr>
                            <td>pending</td>
                            <td>任务已添加，等待执行</td>
                            <td>processing, cancelled</td>
                        </tr>
                        <tr>
                            <td>processing</td>
                            <td>任务正在执行中</td>
                            <td>completed, failed, cancelled</td>
                        </tr>
                        <tr>
                            <td>completed</td>
                            <td>任务成功完成</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>failed</td>
                            <td>任务执行失败</td>
                            <td>pending (重试)</td>
                        </tr>
                        <tr>
                            <td>cancelled</td>
                            <td>任务被取消</td>
                            <td>pending (重新添加)</td>
                        </tr>
                    </table>
                    
                    <h3>任务队列设计</h3>
                    <pre><code>class NavigationQueue:
    def __init__(self):
        self.queue = []  # 待执行任务队列
        self.current_task = None  # 当前执行的任务
        self.is_processing = False  # 是否正在处理任务
        self.completed_tasks = []  # 已完成的任务
        self.failed_tasks = []  # 失败的任务
        
    def add_task(self, task):
        """添加新任务到队列"""
        task['status'] = TaskStatus.PENDING.value
        task['created_at'] = time.time()
        self.queue.append(task)
        self.process_queue()
    
    def process_queue(self):
        """处理任务队列"""
        if not self.is_processing and self.queue:
            self.is_processing = True
            self.current_task = self.queue.pop(0)
            self.current_task['status'] = TaskStatus.PROCESSING.value
            self.current_task['started_at'] = time.time()
            
            # 执行当前任务
            self.execute_task(self.current_task)</code></pre>
                </div>
                <div class="footer">第 8 页</div>
            </div>
            
            <!-- 核心技术点6 -->
            <div class="slide" id="slide9">
                <h2 class="slide-title">核心技术点：导航状态监控系统</h2>
                <div class="slide-content">
                    <p>为了提供良好的用户体验，需要实时监控导航状态并将反馈信息发送到Web前端。</p>
                    
                    <h3>状态监控系统设计</h3>
                    <pre><code>class NavigationMonitor:
    def __init__(self):
        self.current_pose = None  # 当前位置
        self.target_pose = None  # 目标位置
        self.start_time = None  # 导航开始时间
        self.elapsed_time = 0  # 已用时间
        self.distance_traveled = 0  # 已行驶距离
        self.estimated_time_arrival = 0  # 预计到达时间
        self.navigation_status = 'idle'  # 导航状态
        self.last_pose = None  # 上一时刻位置
    
    def start_navigation(self, target_pose):
        """开始导航监控"""
        self.target_pose = target_pose
        self.start_time = time.time()
        self.elapsed_time = 0
        self.distance_traveled = 0
        self.navigation_status = 'navigating'
        
        # 计算初始距离
        if self.current_pose is not None:
            dx = target_pose.position.x - self.current_pose.position.x
            dy = target_pose.position.y - self.current_pose.position.y
            self.initial_distance = math.sqrt(dx**2 + dy**2)
        else:
            self.initial_distance = 0
    
    def update_status(self):
        """更新导航状态"""
        if self.navigation_status == 'navigating':
            # 更新已用时间
            now = time.time()
            self.elapsed_time = now - self.start_time
            
            # 计算预计到达时间（基于平均速度）
            if self.distance_traveled > 0 and self.elapsed_time > 0:
                average_speed = self.distance_traveled / self.elapsed_time
                remaining_distance = self.calculate_remaining_distance()
                
                if average_speed > 0:
                    self.estimated_time_arrival = remaining_distance / average_speed
                else:
                    self.estimated_time_arrival = float('inf')
            
            # 发送状态更新到Web客户端
            # socketio.emit('navigation_status', {
            #     'status': self.navigation_status,
            #     'elapsed_time': self.elapsed_time,
            #     'distance_traveled': self.distance_traveled,
            #     'eta': self.estimated_time_arrival,
            #     'progress': self.calculate_progress()
            # })</code></pre>
                </div>
                <div class="footer">第 9 页</div>
            </div>
            
            <!-- 动手实践部分1 -->
            <div class="slide" id="slide10">
                <h2 class="slide-title">四、动手实践部分：实现导航动作客户端</h2>
                <div class="slide-content">
                    <p><strong>目标：</strong>创建ROS 2节点，实现与Nav2导航栈的通信</p>
                    
                    <p><strong>步骤：</strong></p>
                    <ol>
                        <li>创建新的ROS 2包用于导航控制</li>
                        <li>实现动作客户端，连接到NavigateToPose动作服务器</li>
                        <li>添加目标发送、结果处理和反馈回调功能</li>
                        <li>测试与Nav2的通信</li>
                    </ol>
                    
                    <p><strong>代码示例：</strong></p>
                    <pre><code>#!/usr/bin/env python3
"""
导航动作客户端实现
适用于Ubuntu 22.04 + ROS2 Humble
实现与Nav2导航栈的通信
"""

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus

class NavigationClient(Node):
    def __init__(self):
        super().__init__('navigation_client')
        
        # 创建动作客户端，连接到NavigateToPose动作服务器
        self.action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        
        self.get_logger().info('导航客户端已启动')
    
    def send_goal(self, x, y):
        # 等待动作服务器可用，设置5秒超时
        if not self.action_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('导航服务器未响应')
            return False
        
        # 创建目标消息
        goal_msg = NavigateToPose.Goal()
        pose = PoseStamped()
        pose.header.frame_id = 'map'  # 使用map坐标系
        pose.header.stamp = self.get_clock().now().to_msg()
        pose.pose.position.x = x  # 目标点x坐标
        pose.pose.position.y = y  # 目标点y坐标
        pose.pose.orientation.w = 1.0  # 默认朝向
        
        goal_msg.pose = pose
        
        # 发送目标
        self.send_goal_future = self.action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self.send_goal_future.add_done_callback(self.goal_response_callback)
        
        return True
    
    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('导航目标被拒绝')
            return
        
        self.get_logger().info('导航目标已接受')
        
        # 获取结果
        self.get_result_future = goal_handle.get_result_async()
        self.get_result_future.add_done_callback(self.get_result_callback)
    
    def get_result_callback(self, future):
        result = future.result().result
        status = future.result().status
        
        if status == GoalStatus.STATUS_SUCCEEDED:
            self.get_logger().info('导航成功完成')
        else:
            self.get_logger().info(f'导航失败，状态码: {status}')
        
        # 发送结果到Web客户端
        self.send_result_to_web(status)</code></pre>
                </div>
                <div class="footer">第 10 页</div>
            </div>
            
            <!-- 动手实践部分2 -->
            <div class="slide" id="slide11">
                <h2 class="slide-title">动手实践部分：集成导航控制到Web服务器</h2>
                <div class="slide-content">
                    <p><strong>目标：</strong>将导航控制功能集成到Flask Web服务器中</p>
                    
                    <p><strong>步骤：</strong></p>
                    <ol>
                        <li>在Flask应用中创建导航控制接口</li>
                        <li>添加WebSocket事件处理，接收前端导航请求</li>
                        <li>实现导航结果和反馈的Web推送</li>
                        <li>测试Web端导航控制功能</li>
                    </ol>
                    
                    <p><strong>代码示例：</strong></p>
                    <pre><code>#!/usr/bin/env python3
"""
Flask Web服务器集成ROS 2导航功能
适用于Ubuntu 22.04 + ROS2 Humble
提供Web接口控制机器人导航
"""

from flask import Flask, render_template, request, jsonify
from flask_socketio import SocketIO, emit
import rclpy
from rclpy.executors import MultiThreadedExecutor
import threading
import time
import json

# 创建Flask应用和SocketIO
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_secret_key'
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading')

# 全局变量，用于存储ROS 2节点
navigation_node = None
ros_executor = None

# WebSocket事件处理
@socketio.on('connect')
def handle_connect():
    """处理客户端连接"""
    print('客户端已连接')
    emit('connection_status', {'status': 'connected', 'message': '已连接到服务器'})

@socketio.on('disconnect')
def handle_disconnect():
    """处理客户端断开连接"""
    print('客户端已断开连接')

@socketio.on('navigate_to')
def handle_navigate_to(data):
    """处理导航请求"""
    x = data.get('x', 0)
    y = data.get('y', 0)
    
    print(f'收到导航请求: ({x}, {y})')
    
    # 发送导航目标
    # success = navigation_node.send_goal(x, y)  # 实际使用时取消注释
    success = True  # 模拟成功
    
    if success:
        emit('navigation_status', {'status': 'accepted', 'message': '导航目标已接受'})
    else:
        emit('navigation_status', {'status': 'rejected', 'message': '导航服务器未响应'})

# RESTful API接口
@app.route('/api/navigate', methods=['POST'])
def api_navigate():
    """REST API导航接口"""
    data = request.get_json()
    
    if not data or 'x' not in data or 'y' not in data:
        return jsonify({'error': '缺少x或y参数'}), 400
    
    x = data['x']
    y = data['y']
    
    # 发送导航目标
    # success = navigation_node.send_goal(x, y)  # 实际使用时取消注释
    success = True  # 模拟成功
    
    if success:
        return jsonify({'status': 'accepted', 'message': '导航目标已接受'})
    else:
        return jsonify({'status': 'rejected', 'message': '导航服务器未响应'}), 500</code></pre>
                </div>
                <div class="footer">第 11 页</div>
            </div>
            
            <!-- 动手实践部分3 -->
            <div class="slide" id="slide12">
                <h2 class="slide-title">动手实践部分：实现Web前端导航控制界面</h2>
                <div class="slide-content">
                    <p><strong>目标：</strong>创建Web前端的导航控制界面，实现目标设置和状态显示</p>
                    
                    <p><strong>步骤：</strong></p>
                    <ol>
                        <li>创建导航控制面板HTML结构</li>
                        <li>实现目标点设置和发送功能</li>
                        <li>添加导航状态显示区域</li>
                        <li>实现取消导航功能</li>
                    </ol>
                    
                    <p><strong>HTML结构示例：</strong></p>
                    <pre><code>&lt;div class="container"&gt;
    &lt;h1&gt;机器人导航控制&lt;/h1&gt;
    
    &lt;div class="control-panel"&gt;
        &lt;div class="input-group"&gt;
            &lt;label for="target-x"&gt;目标点 X 坐标&lt;/label&gt;
            &lt;input type="number" id="target-x" step="0.1" value="2.0"&gt;
        &lt;/div&gt;
        &lt;div class="input-group"&gt;
            &lt;label for="target-y"&gt;目标点 Y 坐标&lt;/label&gt;
            &lt;input type="number" id="target-y" step="0.1" value="3.0"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class="button-group"&gt;
        &lt;button id="btn-navigate" class="btn-primary"&gt;开始导航&lt;/button&gt;
        &lt;button id="btn-cancel" class="btn-danger"&gt;取消导航&lt;/button&gt;
        &lt;button id="btn-clear" class="btn-secondary"&gt;清除状态&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;div class="status-panel"&gt;
        &lt;h3&gt;导航状态&lt;/h3&gt;
        &lt;div class="status-item"&gt;
            &lt;span class="status-label"&gt;状态:&lt;/span&gt;
            &lt;span id="status-text"&gt;就绪&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="status-item"&gt;
            &lt;span class="status-label"&gt;进度:&lt;/span&gt;
            &lt;span id="progress-text"&gt;0%&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="progress-bar"&gt;
            &lt;div id="progress-bar" class="progress-fill"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="status-item"&gt;
            &lt;span class="status-label"&gt;已用时间:&lt;/span&gt;
            &lt;span id="elapsed-time"&gt;0秒&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
                </div>
                <div class="footer">第 12 页</div>
            </div>
            
            <!-- 动手实践部分4 -->
            <div class="slide" id="slide13">
                <h2 class="slide-title">动手实践部分：前端JavaScript实现</h2>
                <div class="slide-content">
                    <p>实现前端JavaScript代码，处理用户交互和WebSocket通信：</p>
                    
                    <pre><code>// 初始化SocketIO连接
const socket = io();

// DOM元素
const targetXInput = document.getElementById('target-x');
const targetYInput = document.getElementById('target-y');
const navigateBtn = document.getElementById('btn-navigate');
const cancelBtn = document.getElementById('btn-cancel');
const clearBtn = document.getElementById('btn-clear');
const statusText = document.getElementById('status-text');
const progressText = document.getElementById('progress-text');
const progressBar = document.getElementById('progress-bar');
const elapsedTime = document.getElementById('elapsed-time');

// 导航状态
let isNavigating = false;
let navigationTimer = null;

// 按钮事件监听
navigateBtn.addEventListener('click', () => {
    const x = parseFloat(targetXInput.value);
    const y = parseFloat(targetYInput.value);
    
    if (isNaN(x) || isNaN(y)) {
        alert('请输入有效的坐标值');
        return;
    }
    
    // 发送导航请求
    socket.emit('navigate_to', { x, y });
    
    // 更新状态
    isNavigating = true;
    statusText.textContent = '导航中';
    statusText.style.color = '#3498db';
    
    // 启动计时器
    startNavigationTimer();
});

cancelBtn.addEventListener('click', () => {
    // 发送取消导航请求
    socket.emit('cancel_navigation');
    
    // 更新状态
    isNavigating = false;
    statusText.textContent = '已取消';
    statusText.style.color = '#e74c3c';
    
    // 停止计时器
    stopNavigationTimer();
});

// SocketIO事件处理
socket.on('connect', () => {
    statusText.textContent = '已连接到服务器';
    statusText.style.color = '#2ecc71';
});

socket.on('navigation_status', (data) => {
    statusText.textContent = data.message;
    
    if (data.status === 'accepted') {
        statusText.style.color = '#2ecc71';
    } else if (data.status === 'rejected') {
        statusText.style.color = '#e74c3c';
    }
});

socket.on('navigation_result', (data) => {
    isNavigating = false;
    
    if (data.status === 'completed') {
        statusText.textContent = '导航完成';
        statusText.style.color = '#2ecc71';
    } else {
        statusText.textContent = '导航失败: ' + data.message;
        statusText.style.color = '#e74c3c';
    }
    
    // 停止计时器
    stopNavigationTimer();
});

socket.on('navigation_feedback', (data) => {
    // 更新当前位置
    currentPosition.textContent = `(${data.current_pose.x.toFixed(2)}, ${data.current_pose.y.toFixed(2)})`;
    
    // 更新已行驶距离
    distanceTraveled.textContent = `${data.distance_traveled.toFixed(2)}米`;
    
    // 更新进度（如果有进度信息）
    if (data.progress !== undefined) {
        progressText.textContent = `${data.progress.toFixed(1)}%`;
        progressBar.style.width = `${data.progress}%`;
    }
});</code></pre>
                </div>
                <div class="footer">第 13 页</div>
            </div>
            
            <!-- 动手实践部分5 -->
            <div class="slide" id="slide14">
                <h2 class="slide-title">动手实践部分：实现任务队列管理系统</h2>
                <div class="slide-content">
                    <p><strong>目标：</strong>扩展导航控制系统，支持多任务队列管理</p>
                    
                    <p><strong>步骤：</strong></p>
                    <ol>
                        <li>创建任务队列管理类</li>
                        <li>实现任务添加、执行和状态跟踪功能</li>
                        <li>添加任务优先级和重试机制</li>
                        <li>创建Web前端任务管理界面</li>
                    </ol>
                    
                    <p><strong>代码示例：</strong></p>
                    <pre><code>#!/usr/bin/env python3
"""
任务队列管理系统
适用于Ubuntu 22.04 + ROS2 Humble
支持多任务管理、优先级和重试机制
"""

import time
from enum import Enum
import threading
from collections import deque

# 任务优先级枚举
class TaskPriority(Enum):
    HIGH = 'high'
    NORMAL = 'normal'
    LOW = 'low'

# 任务状态枚举
class TaskStatus(Enum):
    PENDING = 'pending'
    PROCESSING = 'processing'
    COMPLETED = 'completed'
    FAILED = 'failed'
    CANCELLED = 'cancelled'

class TaskQueueManager:
    def __init__(self):
        self.pending_tasks = deque()  # 待处理任务队列
        self.current_task = None      # 当前任务
        self.completed_tasks = []     # 已完成任务
        self.failed_tasks = []        # 失败任务
        self.is_processing = False    # 是否正在处理任务
        self.lock = threading.Lock()  # 线程锁
    
    def add_task(self, task_data):
        """添加新任务"""
        with self.lock:
            task = {
                'id': self.generate_task_id(),
                'type': task_data.get('type', 'navigation'),
                'target': task_data.get('target', {}),
                'priority': task_data.get('priority', TaskPriority.NORMAL.value),
                'max_retries': task_data.get('max_retries', 3),
                'retry_count': 0,
                'status': TaskStatus.PENDING.value,
                'created_at': time.time(),
                'updated_at': time.time()
            }
            
            # 根据优先级插入队列
            if task['priority'] == TaskPriority.HIGH.value:
                self.pending_tasks.appendleft(task)
            else:
                self.pending_tasks.append(task)
            
            # 通知Web客户端
            self.notify_task_added(task)
            
            # 尝试处理任务
            self.process_queue()
            
            return task['id']
    
    def process_queue(self):
        """处理任务队列"""
        with self.lock:
            if self.is_processing or not self.pending_tasks:
                return
            
            self.is_processing = True
            self.current_task = self.pending_tasks.popleft()
            self.current_task['status'] = TaskStatus.PROCESSING.value
            self.current_task['started_at'] = time.time()
            self.current_task['updated_at'] = time.time()
            
            # 通知Web客户端
            self.notify_task_started(self.current_task)
            
            # 执行任务
            self.execute_task(self.current_task)</code></pre>
                </div>
                <div class="footer">第 14 页</div>
            </div>
            
            <!-- 动手实践部分6 -->
            <div class="slide" id="slide15">
                <h2 class="slide-title">动手实践部分：任务队列管理（续）</h2>
                <div class="slide-content">
                    <p>任务队列管理的核心方法实现：</p>
                    
                    <pre><code>    def execute_task(self, task):
        """执行任务"""
        # 在实际应用中，这里应该调用相应的执行方法
        if task['type'] == 'navigation':
            # 执行导航任务
            target = task['target']
            # success = navigation_node.send_goal(target.get('x', 0), target.get('y', 0))
            success = True  # 模拟成功
            
            if not success:
                self.task_failed(task, '无法连接到导航服务器')
            else:
                # 模拟任务执行
                print(f"执行导航任务 {task['id']}: 目标({target.get('x', 0)}, {target.get('y', 0)})")
                # 在实际应用中，应该等待导航完成回调
                # 这里使用定时器模拟任务完成
                timer = threading.Timer(2.0, self.task_completed, [task['id']])
                timer.start()
        else:
            # 其他类型的任务
            self.task_failed(task, '未知任务类型')
    
    def task_completed(self, task_id):
        """任务完成回调"""
        with self.lock:
            if not self.current_task or self.current_task['id'] != task_id:
                return
            
            self.current_task['status'] = TaskStatus.COMPLETED.value
            self.current_task['completed_at'] = time.time()
            self.current_task['updated_at'] = time.time()
            
            self.completed_tasks.append(self.current_task)
            
            # 通知Web客户端
            self.notify_task_completed(self.current_task)
            
            # 处理下一个任务
            self.is_processing = False
            self.current_task = None
            self.process_queue()
    
    def task_failed(self, task, reason):
        """任务失败处理"""
        with self.lock:
            task['status'] = TaskStatus.FAILED.value
            task['failed_at'] = time.time()
            task['updated_at'] = time.time()
            task['failure_reason'] = reason
            
            # 检查是否可重试
            if task['retry_count'] < task['max_retries']:
                task['retry_count'] += 1
                task['status'] = TaskStatus.PENDING.value
                task['updated_at'] = time.time()
                
                # 重新加入队列（降低优先级）
                self.pending_tasks.append(task)
                
                # 通知Web客户端
                self.notify_task_retry(task)
            else:
                # 最终失败
                self.failed_tasks.append(task)
                
                # 通知Web客户端
                self.notify_task_failed(task, reason)
            
            # 处理下一个任务
            self.is_processing = False
            self.current_task = None
            self.process_queue()</code></pre>
                </div>
                <div class="footer">第 15 页</div>
            </div>
            
            <!-- 考核方法 -->
            <div class="slide" id="slide16">
                <h2 class="slide-title">五、考核方法</h2>
                <div class="slide-content">
                    <h3>考核标准与分值分配</h3>
                    <table>
                        <tr>
                            <th>考核项目</th>
                            <th>分值</th>
                            <th>评分标准</th>
                        </tr>
                        <tr>
                            <td>导航动作客户端实现</td>
                            <td>25%</td>
                            <td>能够正确连接Nav2动作服务器并发送目标，代码结构清晰，错误处理完善</td>
                        </tr>
                        <tr>
                            <td>Web服务器集成</td>
                            <td>20%</td>
                            <td>成功将导航控制集成到Flask Web服务器，实现WebSocket通信和RESTful API</td>
                        </tr>
                        <tr>
                            <td>Web前端界面</td>
                            <td>20%</td>
                            <td>导航控制界面功能完整，用户体验良好，状态显示清晰直观</td>
                        </tr>
                        <tr>
                            <td>任务队列管理</td>
                            <td>25%</td>
                            <td>实现多任务队列管理，支持优先级和重试，状态跟踪完善</td>
                        </tr>
                        <tr>
                            <td>代码质量与文档</td>
                            <td>10%</td>
                            <td>代码结构清晰，注释完整，文档齐全，遵循Ubuntu 22.04和ROS2 Humble最佳实践</td>
                        </tr>
                    </table>
                    
                    <h3>具体考核方式</h3>
                    <ol>
                        <li><strong>功能演示（60%）</strong>：学生演示实现的导航控制功能，包括单目标导航、多任务队列管理</li>
                        <li><strong>代码审查（30%）</strong>：老师检查代码质量，评估实现方法的合理性和效率</li>
                        <li><strong>问答测试（10%）</strong>：老师提问关于实现原理和技术细节的问题，评估理解程度</li>
                    </ol>
                </div>
                <div class="footer">第 16 页</div>
            </div>
            
            <!-- 调试工具和调试方法1 -->
            <div class="slide" id="slide17">
                <h2 class="slide-title">六、调试工具和调试方法</h2>
                <div class="slide-content">
                    <h3>调试工具</h3>
                    <ul>
                        <li><strong>ROS 2命令行工具</strong>：查看节点、话题、服务和动作状态</li>
                        <li><strong>RViz</strong>：可视化机器人状态、地图和导航路径</li>
                        <li><strong>浏览器开发者工具</strong>：调试Web前端，监控网络请求</li>
                        <li><strong>rqt</strong>：ROS 2图形化工具，用于监控和调试</li>
                        <li><strong>日志系统</strong>：使用ROS 2日志功能记录调试信息</li>
                    </ul>
                    
                    <h3>常用ROS 2调试命令</h3>
                    <table>
                        <tr>
                            <th>命令</th>
                            <th>功能</th>
                            <th>示例</th>
                        </tr>
                        <tr>
                            <td>ros2 node list</td>
                            <td>查看所有运行的节点</td>
                            <td>ros2 node list</td>
                        </tr>
                        <tr>
                            <td>ros2 topic list</td>
                            <td>查看所有活跃的话题</td>
                            <td>ros2 topic list</td>
                        </tr>
                        <tr>
                            <td>ros2 action list</td>
                            <td>查看所有可用的动作</td>
                            <td>ros2 action list</td>
                        </tr>
                        <tr>
                            <td>ros2 topic echo</td>
                            <td>监听特定话题的消息</td>
                            <td>ros2 topic echo /amcl_pose</td>
                        </tr>
                        <tr>
                            <td>ros2 service list</td>
                            <td>查看所有可用的服务</td>
                            <td>ros2 service list</td>
                        </tr>
                    </table>
                </div>
                <div class="footer">第 17 页</div>
            </div>
            
            <!-- 调试工具和调试方法2 -->
            <div class="slide" id="slide18">
                <h2 class="slide-title">调试工具和调试方法（续）</h2>
                <div class="slide-content">
                    <h3>常见问题与解决方案</h3>
                    <table>
                        <tr>
                            <th>常见问题</th>
                            <th>解决方案</th>
                        </tr>
                        <tr>
                            <td>无法连接到Nav2动作服务器</td>
                            <td>检查Nav2是否正常运行，确认动作服务器名称是否正确</td>
                        </tr>
                        <tr>
                            <td>导航目标被拒绝</td>
                            <td>检查目标点是否在地图范围内，是否可达</td>
                        </tr>
                        <tr>
                            <td>任务队列阻塞</td>
                            <td>添加超时机制和错误处理，实现任务重试机制</td>
                        </tr>
                        <tr>
                            <td>Web前端状态更新延迟</td>
                            <td>优化网络通信，减少不必要的数据传输</td>
                        </tr>
                        <tr>
                            <td>ROS 2与Flask集成问题</td>
                            <td>使用多线程处理ROS 2节点，避免阻塞主线程</td>
                        </tr>
                    </table>
                    
                    <h3>调试代码示例</h3>
                    <pre><code>#!/usr/bin/env python3
"""
调试日志示例
适用于Ubuntu 22.04 + ROS2 Humble
展示如何添加详细的日志记录来辅助调试
"""

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from nav2_msgs.action import NavigateToPose

class DebugNavigationClient(Node):
    def __init__(self):
        super().__init__('debug_navigation_client')
        
        # 设置日志级别为DEBUG，输出详细信息
        self.get_logger().set_level(rclpy.logging.LoggingSeverity.DEBUG)
        
        # 创建动作客户端
        self.action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        
        self.get_logger().debug('调试导航客户端初始化完成')
    
    def send_goal(self, x, y):
        self.get_logger().debug(f'准备发送导航目标: ({x}, {y})')
        
        # 等待动作服务器可用
        if not self.action_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('导航服务器未响应')
            return False
        
        self.get_logger().debug('导航服务器可用，准备发送目标')
        
        # 创建目标消息
        goal_msg = NavigateToPose.Goal()
        pose = PoseStamped()
        pose.header.frame_id = 'map'
        pose.header.stamp = self.get_clock().now().to_msg()
        pose.pose.position.x = x
        pose.pose.position.y = y
        pose.pose.orientation.w = 1.0
        
        goal_msg.pose = pose
        
        self.get_logger().debug('目标消息创建完成，准备发送')
        
        # 发送目标
        self.send_goal_future = self.action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self.send_goal_future.add_done_callback(self.goal_response_callback)
        
        self.get_logger().debug('目标已发送，等待响应')
        
        return True</code></pre>
                </div>
                <div class="footer">第 18 页</div>
            </div>
            
            <!-- 调试工具和调试方法3 -->
            <div class="slide" id="slide19">
                <h2 class="slide-title">调试工具和调试方法（续）</h2>
                <div class="slide-content">
                    <h3>调试场景与方法</h3>
                    <table>
                        <tr>
                            <th>调试场景</th>
                            <th>调试方法</th>
                        </tr>
                        <tr>
                            <td>动作服务器连接问题</td>
                            <td>
                                <ol>
                                    <li>使用<code>ros2 action list</code>检查动作服务器是否可用</li>
                                    <li>使用<code>ros2 action info &lt;action_name&gt;</code>查看动作服务器信息</li>
                                    <li>检查动作客户端代码中的服务器名称是否正确</li>
                                </ol>
                            </td>
                        </tr>
                        <tr>
                            <td>导航目标被拒绝</td>
                            <td>
                                <ol>
                                    <li>使用RViz检查目标点是否在地图范围内</li>
                                    <li>检查目标点是否在障碍物内部或不可达区域</li>
                                    <li>使用<code>ros2 topic echo</code>监控相关话题，查找错误信息</li>
                                </ol>
                            </td>
                        </tr>
                        <tr>
                            <td>Web前端状态不更新</td>
                            <td>
                                <ol>
                                    <li>使用浏览器开发者工具检查WebSocket连接状态</li>
                                    <li>检查后端是否正确发送了状态更新</li>
                                    <li>添加前端日志，确认是否正确接收和处理消息</li>
                                </ol>
                            </td>
                        </tr>
                        <tr>
                            <td>任务队列阻塞</td>
                            <td>
                                <ol>
                                    <li>添加详细的日志记录，跟踪任务状态变化</li>
                                    <li>实现超时机制，防止单个任务无限期阻塞队列</li>
                                    <li>添加队列监控功能，定期检查队列状态</li>
                                </ol>
                            </td>
                        </tr>
                    </table>
                </div>
                <div class="footer">第 19 页</div>
            </div>
            
            <!-- 调试工具和调试方法4 -->
            <div class="slide" id="slide20">
                <h2 class="slide-title">调试工具和调试方法（续）</h2>
                <div class="slide-content">
                    <h3>使用RViz进行可视化调试</h3>
                    <p>RViz是ROS 2中最强大的可视化工具，可以用于：</p>
                    <ul>
                        <li>查看机器人在地图中的位置</li>
                        <li>显示导航目标和规划路径</li>
                        <li>监控传感器数据和障碍物信息</li>
                        <li>调试定位和导航问题</li>
                    </ul>
                    
                    <h3>RViz常用配置</h3>
                    <table>
                        <tr>
                            <th>显示类型</th>
                            <th>功能</th>
                            <th>话题/服务</th>
                        </tr>
                        <tr>
                            <td>Map</td>
                            <td>显示地图</td>
                            <td>/map</td>
                        </tr>
                        <tr>
                            <td>RobotModel</td>
                            <td>显示机器人模型</td>
                            <td>/robot_description</td>
                        </tr>
                        <tr>
                            <td>Pose</td>
                            <td>显示机器人位姿</td>
                            <td>/amcl_pose</td>
                        </tr>
                        <tr>
                            <td>Path</td>
                            <td>显示规划路径</td>
                            <td>/plan, /global_plan, /local_plan</td>
                        </tr>
                        <tr>
                            <td>LaserScan</td>
                            <td>显示激光雷达数据</td>
                            <td>/scan</td>
                        </tr>
                    </table>
                    
                    <h3>启动RViz命令</h3>
                    <pre><code># 启动RViz
ros2 run rviz2 rviz2

# 或者使用launch文件启动RViz和导航栈
ros2 launch nav2_bringup tb3_simulation_launch.py</code></pre>
                </div>
                <div class="footer">第 20 页</div>
            </div>
            
            <!-- 调试工具和调试方法5 -->
            <div class="slide" id="slide21">
                <h2 class="slide-title">调试工具和调试方法（续）</h2>
                <div class="slide-content">
                    <h3>使用rqt进行图形化调试</h3>
                    <p>rqt是ROS 2的图形化工具框架，包含多种插件用于监控和调试：</p>
                    
                    <table>
                        <tr>
                            <th>rqt插件</th>
                            <th>功能</th>
                            <th>用途</th>
                        </tr>
                        <tr>
                            <td>rqt_graph</td>
                            <td>显示节点图</td>
                            <td>查看节点之间的连接关系</td>
                        </tr>
                        <tr>
                            <td>rqt_console</td>
                            <td>日志查看器</td>
                            <td>查看和分析系统日志</td>
                        </tr>
                        <tr>
                            <td>rqt_plot</td>
                            <td>数据绘图</td>
                            <td>可视化数值数据的变化趋势</td>
                        </tr>
                        <tr>
                            <td>rqt_bag</td>
                            <td>数据记录和回放</td>
                            <td>记录和回放话题数据</td>
                        </tr>
                        <tr>
                            <td>rqt_action</td>
                            <td>动作监控</td>
                            <td>监控动作服务器和客户端的交互</td>
                        </tr>
                    </table>
                    
                    <h3>启动rqt命令</h3>
                    <pre><code># 启动rqt图形界面
ros2 run rqt_gui rqt_gui

# 启动特定rqt插件
ros2 run rqt_console rqt_console
ros2 run rqt_graph rqt_graph
ros2 run rqt_plot rqt_plot</code></pre>
                </div>
                <div class="footer">第 21 页</div>
            </div>
            
            <!-- 调试工具和调试方法6 -->
            <div class="slide" id="slide22">
                <h2 class="slide-title">调试工具和调试方法（续）</h2>
                <div class="slide-content">
                    <h3>Web前端调试方法</h3>
                    <p>Web前端调试主要使用浏览器开发者工具：</p>
                    
                    <table>
                        <tr>
                            <th>调试工具</th>
                            <th>功能</th>
                            <th>用途</th>
                        </tr>
                        <tr>
                            <td>Elements</td>
                            <td>元素检查</td>
                            <td>查看和修改HTML和CSS</td>
                        </tr>
                        <tr>
                            <td>Console</td>
                            <td>控制台</td>
                            <td>查看JavaScript错误和日志输出</td>
                        </tr>
                        <tr>
                            <td>Network</td>
                            <td>网络监控</td>
                            <td>监控HTTP请求和WebSocket连接</td>
                        </tr>
                        <tr>
                            <td>Sources</td>
                            <td>源代码调试</td>
                            <td>设置断点和调试JavaScript代码</td>
                        </tr>
                        <tr>
                            <td>Application</td>
                            <td>应用信息</td>
                            <td>查看存储、缓存和服务工作者</td>
                        </tr>
                    </table>
                    
                    <h3>打开浏览器开发者工具</h3>
                    <ul>
                        <li><strong>Chrome/Firefox/Edge</strong>：按F12键或右键选择"检查"</li>
                        <li><strong>Safari</strong>：需在偏好设置中启用"开发"菜单，然后选择"显示Web检查器"</li>
                    </ul>
                    
                    <h3>WebSocket调试技巧</h3>
                    <pre><code>// 添加WebSocket调试代码
socket.on('connect', function() {
    console.log('WebSocket连接已建立');
});

socket.on('disconnect', function() {
    console.log('WebSocket连接已断开');
});

socket.on('navigation_status', function(data) {
    console.log('收到导航状态:', data);
});

// 手动发送测试消息
function sendTestMessage() {
    socket.emit('navigate_to', {x: 2.0, y: 3.0});
}</code></pre>
                </div>
                <div class="footer">第 22 页</div>
            </div>
            
            <!-- 调试工具和调试方法7 -->
            <div class="slide" id="slide23">
                <h2 class="slide-title">调试工具和调试方法（续）</h2>
                <div class="slide-content">
                    <h3>系统性能监控</h3>
                    <p>监控系统性能是确保导航系统稳定运行的重要环节：</p>
                    
                    <table>
                        <tr>
                            <th>监控指标</th>
                            <th>监控工具</th>
                            <th>正常范围</th>
                        </tr>
                        <tr>
                            <td>CPU使用率</td>
                            <td>top, htop, ros2 topic echo /system_metrics</td>
                            <td>&lt; 80%</td>
                        </tr>
                        <tr>
                            <td>内存使用率</td>
                            <td>free, top, ros2 topic echo /system_metrics</td>
                            <td>&lt; 80%</td>
                        </tr>
                        <tr>
                            <td>磁盘使用率</td>
                            <td>df, du</td>
                            <td>&lt; 90%</td>
                        </tr>
                        <tr>
                            <td>网络延迟</td>
                            <td>ping, iperf</td>
                            <td>&lt; 100ms</td>
                        </tr>
                        <tr>
                            <td>ROS 2节点状态</td>
                            <td>ros2 node list, ros2 node info</td>
                            <td>所有节点正常运行</td>
                        </tr>
                    </table>
                    
                    <h3>性能监控命令示例</h3>
                    <pre><code># 查看CPU和内存使用情况
top
htop

# 查看磁盘使用情况
df -h
du -sh /path/to/directory

# 测试网络延迟
ping <hostname_or_ip>

# 查看ROS 2节点状态
ros2 node list
ros2 node info &lt;node_name&gt;

# 监控系统指标（需要安装system_metrics_collector包）
ros2 topic echo /system_metrics</code></pre>
                </div>
                <div class="footer">第 23 页</div>
            </div>
            
            <!-- 调试工具和调试方法8 -->
            <div class="slide" id="slide24">
                <h2 class="slide-title">调试工具和调试方法（续）</h2>
                <div class="slide-content">
                    <h3>日志记录最佳实践</h3>
                    <p>良好的日志记录是调试和维护系统的关键：</p>
                    
                    <table>
                        <tr>
                            <th>日志级别</th>
                            <th>使用场景</th>
                            <th>示例</th>
                        </tr>
                        <tr>
                            <td>DEBUG</td>
                            <td>详细的调试信息，开发阶段使用</td>
                            <td>记录函数调用的参数和返回值</td>
                        </tr>
                        <tr>
                            <td>INFO</td>
                            <td>重要的运行时信息</td>
                            <td>记录系统状态变化和重要事件</td>
                        </tr>
                        <tr>
                            <td>WARN</td>
                            <td>可能有问题但不是错误的情况</td>
                            <td>记录非关键的异常情况</td>
                        </tr>
                        <tr>
                            <td>ERROR</td>
                            <td>错误情况，但系统仍可运行</td>
                            <td>记录操作失败但可恢复的错误</td>
                        </tr>
                        <tr>
                            <td>FATAL</td>
                            <td>严重错误，导致系统无法运行</td>
                            <td>记录导致系统崩溃的错误</td>
                        </tr>
                    </table>
                    
                    <h3>ROS 2日志使用示例</h3>
                    <pre><code># 在Python节点中使用日志
self.get_logger().debug('详细的调试信息')
self.get_logger().info('重要的运行时信息')
self.get_logger().warn('可能有问题但不是错误的情况')
self.get_logger().error('错误情况，但系统仍可运行')
self.get_logger().fatal('严重错误，导致系统无法运行')

# 设置日志级别
self.get_logger().set_level(rclpy.logging.LoggingSeverity.DEBUG)

# 查看日志
ros2 topic echo /rosout

# 使用rqt_console查看和分析日志
ros2 run rqt_console rqt_console</code></pre>
                </div>
                <div class="footer">第 24 页</div>
            </div>
            
            <!-- 结束页 -->
            <div class="slide" id="slide25">
                <h2 class="slide-title">课程总结</h2>
                <div class="slide-content" style="text-align: center; margin-top: 100px;">
                    <h3>Web端导航控制与机器人物联网云控系统</h3>
                    <p style="margin-top: 50px; font-size: 1.5rem;">实现了完整的Web端机器人导航控制系统</p>
                    <div style="margin-top: 80px;">
                        <p>涵盖了ROS 2动作系统、任务队列管理、状态监控等核心技术</p>
                        <p>提供了完整的代码实现和调试方法</p>
                    </div>
                    <p style="margin-top: 100px;">谢谢观看</p>
                </div>
                <div class="footer">第 25 页</div>
            </div>
            
            <!-- 幻灯片结束 -->
        </div>
    </div>

    <script>
        // 当前幻灯片索引
        let currentSlide = 1;
        const totalSlides = 25;
        
        // 导航函数
        function navigate(direction) {
            if (direction === 'next' && currentSlide < totalSlides) {
                currentSlide++;
            } else if (direction === 'prev' && currentSlide > 1) {
                currentSlide--;
            } else if (direction === 'home') {
                currentSlide = 1;
            }
            
            // 滚动到目标幻灯片
            const targetSlide = document.getElementById(`slide${currentSlide}`);
            if (targetSlide) {
                targetSlide.scrollIntoView({ behavior: 'smooth' });
            }
        }
        
        // 添加键盘导航支持
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowRight' || event.key === 'PageDown') {
                navigate('next');
            } else if (event.key === 'ArrowLeft' || event.key === 'PageUp') {
                navigate('prev');
            } else if (event.key === 'Home') {
                navigate('home');
            }
        });
        
        // 导出PDF函数
        function exportToPDF() {
            // 选择要导出的容器
            const element = document.getElementById('slides-container');
            
            // 配置html2pdf
            const opt = {
                margin: 10,
                filename: 'web_navigation_control_ppt.pdf',
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { scale: 2 },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
            };
            
            // 使用Promise确保所有内容加载完成
            new Promise((resolve, reject) => {
                // 确保所有图片加载完成
                const images = element.getElementsByTagName('img');
                let loadedImages = 0;
                const totalImages = images.length;
                
                if (totalImages === 0) {
                    resolve();
                    return;
                }
                
                for (let i = 0; i < totalImages; i++) {
                    if (images[i].complete) {
                        loadedImages++;
                    } else {
                        images[i].onload = () => {
                            loadedImages++;
                            if (loadedImages === totalImages) {
                                resolve();
                            }
                        };
                        images[i].onerror = reject;
                    }
                }
                
                if (loadedImages === totalImages) {
                    resolve();
                }
            }).then(() => {
                // 生成PDF
                html2pdf().set(opt).from(element).save();
            }).catch(error => {
                console.error('Error loading images:', error);
                // 即使有图片加载失败，也继续生成PDF
                html2pdf().set(opt).from(element).save();
            });
        }
        
        // 初始滚动到第一页
        window.onload = function() {
            navigate('home');
        };
    </script>
</body>
</html>